package edu.cnu.mdi.view;

import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * Base class for View Information.
 * Extend this for each View type to provide standardized documentation.
 *
 * Design goals:
 * <ul>
 *   <li>Centralize look & feel (typography, spacing, section layout)</li>
 *   <li>Prefer structured data over ad-hoc HTML snippets</li>
 *   <li>Still allow optional raw HTML fragments when needed</li>
 * </ul>
 */
public abstract class AbstractViewInfo {

    // ------------------------------------------------------------------------
    // Mandatory content
    // ------------------------------------------------------------------------

    /** @return The title shown at top of the Info dialog. */
    public abstract String getTitle();

    /** @return Short description of what this view is for. Plain text by default. */
    public abstract String getPurpose();

    // ------------------------------------------------------------------------
    // Optional structured content (preferred)
    // ------------------------------------------------------------------------

    /**
     * Usage bullets (preferred).
     * Each bullet should be plain text (not HTML). The framework will escape it.
     */
    public List<String> getUsageBullets() {
        return Collections.emptyList();
    }

    /**
     * Usage steps (optional alternative to bullets).
     * Each step should be plain text (not HTML). The framework will escape it.
     */
    public List<String> getUsageSteps() {
        return Collections.emptyList();
    }

    /**
     * A map of Key Combo -> Action (e.g., "Ctrl+S" -> "Save").
     * Keys and actions are treated as plain text.
     */
    public Map<String, String> getKeyboardShortcuts() {
        return Collections.emptyMap();
    }

    /** @return Technical notes. Plain text. */
    public String getTechnicalNotes() {
        return null;
    }

    /** @return Footer text. Plain text. */
    public String getFooter() {
        return "Generated by MDI Framework";
    }

    // ------------------------------------------------------------------------
    // Optional raw HTML hooks (use sparingly)
    // ------------------------------------------------------------------------

    /**
     * If you really need custom HTML for purpose, override this and return true.
     * Default: purpose is escaped as plain text.
     */
    protected boolean isPurposeHtml() {
        return false;
    }

    /**
     * If you really need custom HTML for usage, you may return a raw HTML fragment
     * here (e.g., a table, links, etc.). If non-blank, it is inserted as-is.
     *
     * Prefer getUsageBullets() / getUsageSteps() when possible.
     */
    public String getUsageHtml() {
        return null;
    }

    // ------------------------------------------------------------------------
    // Appearance hooks
    // ------------------------------------------------------------------------

    /** Accent color used for section headers. Keep simple; Swing HTML is limited. */
    protected String getAccentColorHex() {
        return "#e67e22";
    }

    /** Primary text color. */
    protected String getTextColorHex() {
        return "#333333";
    }

    /** Title color. */
    protected String getTitleColorHex() {
        return "#222222";
    }

    // ------------------------------------------------------------------------
    // HTML generation
    // ------------------------------------------------------------------------

    public final String getAsHTML() {
        StringBuilder sb = new StringBuilder(2048);

        sb.append("<html><head><style type='text/css'>");

        // Keep CSS conservative: Swing's HTML renderer is old and picky.
        sb.append("body { font-family: sans-serif; color: ").append(getTextColorHex())
          .append("; margin: 18px; }");

        sb.append("h1 { color: ").append(getTitleColorHex())
          .append("; font-size: 20pt; margin: 0 0 10px 0; }");

        sb.append("p { font-size: 12pt; margin: 0 0 10px 0; }");

        sb.append(".sectionTitle { color: ").append(getAccentColorHex())
          .append("; font-size: 14pt; font-weight: bold; margin: 18px 0 6px 0; }");

        sb.append("hr { border: 0; border-top: 1px solid #dddddd; height: 1px; margin: 10px 0 12px 0; }");
        sb.append("ul { margin: 6px 0 10px 14px; padding-left: 10px; }");
        sb.append("ol { margin: 6px 0 10px 22px; }");
        sb.append("li { font-size: 12pt; margin: 0 0 6px 0; }");

        sb.append(".shortcutKey { font-weight: bold; font-family: monospace; background: #eeeeee; padding: 1px 4px; }");

        sb.append(".footer { font-size: 10pt; color: #888888; margin-top: 18px; }");

        sb.append("</style></head><body>");

        // Title
        sb.append("<h1>").append(escape(getTitle())).append("</h1>");

        // Purpose
        String purpose = safe(getPurpose());
        sb.append("<p>");
        sb.append(isPurposeHtml() ? purpose : escape(purpose));
        sb.append("</p>");

        // Horizontal rule separating header from sections
        sb.append("<hr>");

        // Usage (raw HTML fragment has priority; otherwise structured bullets/steps)
        appendUsage(sb);

        // Shortcuts
        appendShortcuts(sb);

        // Technical Notes
        String tech = trimToNull(getTechnicalNotes());
        if (tech != null) {
            sb.append("<div class='sectionTitle'>Technical Details</div>");
            sb.append("<p><i>").append(escape(tech)).append("</i></p>");
        }

        // Footer
        String footer = trimToNull(getFooter());
        if (footer != null) {
            sb.append("<div class='footer'>").append(escape(footer)).append("</div>");
        }

        sb.append("</body></html>");
        return sb.toString();
    }

    private void appendUsage(StringBuilder sb) {
        String usageHtml = trimToNull(getUsageHtml());
        List<String> bullets = nullSafe(getUsageBullets());
        List<String> steps = nullSafe(getUsageSteps());

        boolean hasStructured = (!bullets.isEmpty() || !steps.isEmpty());
        boolean hasHtml = (usageHtml != null);

        if (!hasStructured && !hasHtml) {
            return;
        }

        sb.append("<div class='sectionTitle'>Usage</div>");

        if (hasHtml) {
            // Raw HTML fragment inserted as-is.
            // NOTE: caller is responsible for valid/simple HTML.
            sb.append(usageHtml);
            return;
        }

        // Structured usage
        if (!steps.isEmpty()) {
            sb.append("<ol>");
            for (String s : steps) {
                sb.append("<li>").append(escape(safe(s))).append("</li>");
            }
            sb.append("</ol>");
        }

        if (!bullets.isEmpty()) {
            sb.append("<ul>");
            for (String b : bullets) {
                sb.append("<li>").append(escape(safe(b))).append("</li>");
            }
            sb.append("</ul>");
        }
    }

    private void appendShortcuts(StringBuilder sb) {
        Map<String, String> shortcuts = getKeyboardShortcuts();
        if (shortcuts == null || shortcuts.isEmpty()) {
            return;
        }

        sb.append("<div class='sectionTitle'>Keyboard Shortcuts</div>");
        sb.append("<ul>");
        for (Map.Entry<String, String> entry : shortcuts.entrySet()) {
            String key = escape(safe(entry.getKey()));
            String val = escape(safe(entry.getValue()));
            sb.append("<li><span class='shortcutKey'>").append(key).append("</span> : ").append(val).append("</li>");
        }
        sb.append("</ul>");
    }

    private static List<String> nullSafe(List<String> list) {
        return (list == null) ? Collections.emptyList() : list;
    }

    private static String safe(String s) {
        return (s == null) ? "" : s;
    }

    private static String trimToNull(String s) {
        if (s == null) return null;
        String t = s.trim();
        return t.isEmpty() ? null : t;
    }

    /**
     * Minimal escaping appropriate for Swing HTML.
     * We also convert newlines to <br> so plain text blocks render nicely.
     */
    private static String escape(String s) {
        if (s == null) return "";
        return s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("\n", "<br>");
    }
}